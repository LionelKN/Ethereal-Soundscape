<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Ethereal Soundscape</title>
  <meta name="description" content="Ethereal Soundscape — React + Tone.js" />
  <!-- Tailwind (Play CDN) for quick styling -->
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    html, body, #root { height: 100%; }
    body { background: #0b1220; }
  </style>
</head>
<body>
  <div id="root"></div>

  <!-- React 18 UMD + Babel Standalone (to run TSX in-browser) -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- Tone.js (global Tone) -->
  <script src="https://unpkg.com/tone@14.8.49/build/Tone.js"></script>

  <!-- App Code (TypeScript + React) -->
  <script type="text/babel" data-presets="typescript,react">
    // ================================================================
    // Ethereal Soundscape — compact build (React + Tone.js)
    // Adds: QWERTY/MIDI play, Call‑and‑Response, Random Room Modeling
    // Removed: Visual Feedback (canvas & RAF)
    // Extended: BPM up to 200
    // Added sources: Pluck (crystalline), Choir (soft tape‑like pad)
    // Hardened against sub‑normal param values.
    // ================================================================

    const NOTES = Object.freeze(["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"] as const);
    const SCALES: Record<string, number[]> = Object.freeze({
      Ionian:[0,2,4,5,7,9,11], Dorian:[0,2,3,5,7,9,10], Phrygian:[0,1,3,5,7,8,10],
      Lydian:[0,2,4,6,7,9,11], Mixolydian:[0,2,4,5,7,9,10], Aeolian:[0,2,3,5,7,8,10],
      WholeTone:[0,2,4,6,8,10], Pentatonic:[0,2,4,7,9]
    });

    const QWERTY_MAP: Record<string, typeof NOTES[number]> = {
      a:"C", w:"C#", s:"D", e:"D#", d:"E", f:"F", t:"F#", g:"G", y:"G#", h:"A", u:"A#", j:"B"
    };

    type NoteName = typeof NOTES[number];
    const NOTE_LIST: string[] = [...NOTES];
    const EPS=1e-4;
    const clamp=(v:number,a:number,b:number)=>Math.min(b,Math.max(a,Number.isFinite(v)?v:a));
    const safe01=(v:number)=>v<=0?0:clamp(v,EPS,1);
    const gainToDbSafe01=(v:number)=>v<=0?-90:Tone.gainToDb(clamp(v,EPS,1));
    const safeMod=(n:number,m:number)=>((n%m)+m)%m;
    const isTok=(s:string)=>/^[A-G](#)?[0-8]$/.test(s);
    const buildScale=(root:NoteName|string,scale:string,oct:number[]=[2,3,4,5])=>{
      const i=NOTES.indexOf(root as NoteName);
      const ri=i>=0?i:0;
      const ints=SCALES[scale]||SCALES.Lydian;
      const out:string[]=[];
      for(const o of oct){ for(const k of ints){
        const ix=safeMod(ri+k,12);
        const n=NOTES[ix];
        if(!n) continue;
        const t=\`\${n}\${o}\`;
        if(isTok(t)) out.push(t);
      }}
      return out;
    };
    const INTERVALS=[{t:"16n",b:0.25},{t:"8n",b:0.5},{t:"4n",b:1},{t:"4n.",b:1.5},{t:"2n",b:2},{t:"2n.",b:3},{t:"1n",b:4},{t:"1n.",b:6},{t:"2m",b:8}];
    const densityToInterval=(d:number)=>{
      const des=1/clamp(d,0.05,1);
      let best=INTERVALS[0]; let e=Math.abs(best.b-des);
      for(const c of INTERVALS){ const ee=Math.abs(c.b-des); if(ee<e){best=c; e=ee;} }
      return best.t;
    };
    const rampNorm=(p:any,val:number,sec=0.2)=>{
      const t=val<=0?0:clamp(val,EPS,1);
      try{
        if(val<=0){
          p.cancelScheduledValues?.(Tone.now());
          p.setValueAtTime ? p.setValueAtTime(0,Tone.now()) : p.value=0;
        }else if(typeof p.rampTo==="function"){
          p.rampTo(t,sec);
        }else if(p.linearRampToValueAtTime){
          p.linearRampToValueAtTime(t,Tone.now()+sec);
        }else{
          p.value=t;
        }
      }catch{ try{ p.value=t; }catch{} }
    };

    function App(){
      const {useEffect,useMemo,useRef,useState} = React;
      // musical state
      const [root,setRoot]=useState<NoteName>("D");
      const [scale,setScale]=useState("Lydian");
      const pool=useMemo(()=>buildScale(root,scale,[2,3,4,5]),[root,scale]);
      const lowPool=useMemo(()=>buildScale(root,scale,[1,2]),[root,scale]);
      const highPool=useMemo(()=>buildScale(root,scale,[4,5,6]),[root,scale]);

      // global
      const [isOn,setOn]=useState(false); const [tempo,setTempo]=useState(48);
      const [bloom,setBloom]=useState(0.6); const [shimmer,setShimmer]=useState(0.4);
      const [chorus,setChorus]=useState(0.4); const [spread,setSpread]=useState(0.7);
      const [motion,setMotion]=useState(0.04); const [masterVol,setMaster]=useState(0.9);
      const [density,setDensity]=useState(0.33); const [bellDensity,setBellD]=useState(0.12);
      const [cutDrone,setCutDrone]=useState(500); const [detune,setDetune]=useState(8);
      const [levels,setLevels]=useState({pad:.8,sparkle:.6,noise:.3,drone:.9,sub:.6,bell:.6,grain:.5,pluck:.5,choir:.6});
      const [grain,setGrain]=useState({bits:4,shift:1.6,airy:false,mode:'hz' as 'hz'|'synced',rateHz:9,rateSync:'8n'});
      // spatial + room
      const [orbit,setOrbit]=useState(0.02); const [depth,setDepth]=useState(0.5); const [scatter,setScatter]=useState(0.15);
      const [roomSecs,setRoomSecs]=useState(180);

      // refs: synths/effects
      const pad=useRef<any>(null), sp=useRef<any>(null), ns=useRef<any>(null);
      const drone=useRef<any>(null), sub=useRef<any>(null), bell=useRef<any>(null);
      const pluck=useRef<any>(null), choir=useRef<any>(null);
      const gNoise=useRef<any>(null), gEnv=useRef<any>(null), gGate=useRef<any>(null), gCr=useRef<any>(null), gSh=useRef<any>(null), gDel=useRef<any>(null), gGain=useRef<any>(null);
      const nEnv=useRef<any>(null);
      const master=useRef<any>(null), comp=useRef<any>(null), widen=useRef<any>(null), rev=useRef<any>(null), pitch=useRef<any>(null);
      const layers=useRef<Record<string,any>>({});
      const seq=useRef<any>(null), padL=useRef<any>(null), drL=useRef<any>(null), bellL=useRef<any>(null), roomL=useRef<any>(null), pluckL=useRef<any>(null), choirL=useRef<any>(null);
      const lfoWet=useRef<any>(null);

      // setup per-layer routing (with orbit LFOs)
      const setup=(name:string, src:any, dry=1)=>{
        const f=new Tone.Filter({type:"lowpass",frequency:1200,Q:.4});
        const c=new Tone.Chorus({frequency:.12,depth:clamp(chorus,0,1),feedback:.2,wet:.6}).start();
        const p=new Tone.Phaser({frequency:.05,octaves:2.5,baseFrequency:200,Q:6,wet:.35});
        const pan=new Tone.Panner(0);
        const dg=new Tone.Gain(safe01(dry));
        const sg=new Tone.Gain(safe01(depth));
        src.chain(f,c,p,pan,dg,master.current!);
        pan.connect(sg); sg.connect(rev.current!);
        const baseAmp=clamp(1-scatter,0,1), scAmp=clamp(scatter,0,1);
        const lfo1=new Tone.LFO({frequency:Math.max(0.005,orbit), min:-baseAmp, max:baseAmp}).start();
        const lfo2=new Tone.LFO({frequency:Math.max(0.005,orbit*3.13), min:-scAmp, max:scAmp, phase:137}).start();
        lfo1.connect(pan.pan); lfo2.connect(pan.pan);
        layers.current[name]={filter:f,chor:c,phs:p,pan,dry:dg,send:sg,lfo1,lfo2};
      };

      const start=async()=>{
        await Tone.start(); Tone.Transport.bpm.value=clamp(tempo,20,200);
        master.current=new Tone.Gain(safe01(masterVol));
        comp.current=new Tone.Compressor({threshold:-18,ratio:3,attack:.02,release:.6});
        widen.current=new Tone.StereoWidener({width:clamp(spread,0,1)});
        master.current.chain(comp.current,widen.current,Tone.Destination);
        rev.current=new Tone.Reverb({decay:14,preDelay:.04,wet:clamp(bloom,0,1)});
        pitch.current=new Tone.PitchShift({pitch:12,delayTime:.12,feedback:.35,wet:clamp(shimmer,0,1)});
        rev.current.chain(pitch.current,master.current);

        pad.current=new Tone.PolySynth(Tone.Synth,{oscillator:{type:"sine"},envelope:{attack:4,decay:2,sustain:.8,release:8},volume:gainToDbSafe01(levels.pad)}); setup("pad",pad.current);
        sp.current=new Tone.PolySynth(Tone.AMSynth,{oscillator:{type:"sine"},envelope:{attack:.8,decay:1.5,sustain:.6,release:6},modulationEnvelope:{attack:2,decay:1,sustain:.6,release:6},volume:gainToDbSafe01(levels.sparkle)}); setup("sparkle",sp.current);
        ns.current=new Tone.Noise("pink");
        nEnv.current=new Tone.AmplitudeEnvelope({attack:6,decay:2,sustain:.3,release:10});
        const nG=new Tone.Gain(safe01(levels.noise)); ns.current.chain(nEnv.current,nG); setup("noise",nG,1);
        drone.current=new Tone.PolySynth(Tone.FMSynth,{oscillator:{type:"sine"},modulation:{type:"sine"},harmonicity:.5,modulationIndex:5,envelope:{attack:6,decay:3,sustain:.9,release:10},detune:clamp(detune,-50,50),volume:gainToDbSafe01(levels.drone)}); setup("drone",drone.current);
        layers.current.drone.filter.frequency.value=clamp(cutDrone,80,3000);
        sub.current=new Tone.MonoSynth({oscillator:{type:"sine"},filter:{type:"lowpass",rolloff:-24},envelope:{attack:.01,decay:.4,sustain:.7,release:1.2},filterEnvelope:{attack:.02,decay:.3,sustain:.5,release:.8,baseFrequency:40,octaves:1},volume:gainToDbSafe01(levels.sub)});
        const subDry=new Tone.Gain(1); sub.current.connect(subDry); setup("sub",subDry,1); layers.current.sub.send.gain.value=0;
        bell.current=new Tone.MetalSynth({frequency:440,envelope:{attack:.005,decay:3.5,release:2},harmonicity:5.1,modulationIndex:16,resonance:clamp(4000,500,8000),octaves:1.5,volume:gainToDbSafe01(levels.bell)});
        setup("bells",bell.current);

        pluck.current=new Tone.PluckSynth({ attackNoise: 1.2, dampening: 3200, resonance: 0.8 });
        setup("pluck", pluck.current, 1);
        choir.current=new Tone.PolySynth(Tone.Synth, { oscillator:{type:"triangle"}, envelope:{attack:1.5, decay:1.2, sustain:0.9, release:6}, volume: gainToDbSafe01(levels.choir) });
        setup("choir", choir.current);

        gNoise.current=new Tone.Noise("white");
        gEnv.current=new Tone.AmplitudeEnvelope(
          (grain.airy?{attack:.02,decay:.25,sustain:0,release:.25}:{attack:.005,decay:.18,sustain:0,release:.12}) as any
        );
        const r:any=grain.mode==='synced'?grain.rateSync:clamp(grain.rateHz,1,24);
        gGate.current=new Tone.AutoFilter({type:"square",frequency:r,depth:1,baseFrequency:300,octaves:3}).start();
        gCr.current=new Tone.BitCrusher(clamp(grain.bits,1,8));
        gSh.current=new Tone.FrequencyShifter(clamp(grain.shift,.1,12));
        gDel.current=new Tone.FeedbackDelay(grain.airy?{delayTime:.1,feedback:.35,wet:.5}:{delayTime:.06,feedback:.2,wet:.25});
        gGain.current=new Tone.Gain(safe01(levels.grain));
        const gChain=new Tone.Gain(1);
        gNoise.current.chain(gEnv.current,gGate.current,gCr.current,gSh.current,gDel.current,gGain.current,gChain);
        setup("grain",gChain);

        lfoWet.current=new Tone.LFO({frequency:Math.max(.002, motion*.5), min:.25, max:.85}).start();
        lfoWet.current.connect(rev.current.wet);

        seq.current=new Tone.Loop((t:number)=>{
          if(!pool.length) return;
          const i=Math.floor(Math.random()*pool.length);
          const a=pool[i];
          const iv=[2,4,5,7][Math.floor(Math.random()*4)];
          const b=pool[(i+iv)%pool.length];
          const dur=["2n","1n","1n."][Math.floor(Math.random()*3)];
          sp.current.triggerAttackRelease(Math.random()<.4?[a,b]:[a],dur,t,.7);
        }, densityToInterval(density)).start(0);

        padL.current=new Tone.Loop((t:number)=>{
          if(!pool.length) return;
          const i=Math.floor(Math.random()*pool.length);
          const chord=[pool[i],pool[(i+2)%pool.length],pool[(i+4)%pool.length]];
          pad.current.triggerAttackRelease(chord,"4m",t,.6);
          nEnv.current.triggerAttackRelease("4m",t);
        },"8m").start(0);

        drL.current=new Tone.Loop((t:number)=>{
          if(!lowPool.length) return;
          const i=Math.floor(Math.random()*lowPool.length);
          const base=lowPool[i];
          const fifth=lowPool[(i+4)%lowPool.length];
          const add=Math.random()<.5?[lowPool[(i+7)%lowPool.length]]:[];
          drone.current.triggerAttackRelease([base,fifth,...add],"8m",t,.8);
          const subN=Tone.Frequency(base).transpose(-12).toNote();
          sub.current.triggerAttackRelease(subN,"2m",t,.9);
          const ans=highPool[(i+2)%highPool.length];
          Tone.Transport.scheduleOnce((time:number)=>{ bell.current.triggerAttackRelease(ans,"2n",time,0.6); }, "+2n");
        }, "16m").start(0);

        bellL.current=new Tone.Loop((t:number)=>{
          if(!highPool.length) return;
          const n=highPool[Math.floor(Math.random()*highPool.length)];
          bell.current.triggerAttackRelease(n,"2n",t,0.5+Math.random()*0.3);
        }, densityToInterval(Math.min(.25,Math.max(.05,bellDensity)))).start("+1m");

        pluckL.current=new Tone.Loop((t:number)=>{
          if(!highPool.length) return;
          const n=highPool[Math.floor(Math.random()*highPool.length)];
          pluck.current.triggerAttack(n,t, clamp(levels.pluck,0.2,1));
        }, "2n").start("+2n");

        choirL.current=new Tone.Loop((t:number)=>{
          if(!pool.length) return;
          const i=Math.floor(Math.random()*pool.length);
          const chord=[pool[i], pool[(i+2)%pool.length], pool[(i+4)%pool.length]];
          choir.current.triggerAttackRelease(chord, "2m", t, 0.5);
        }, "16m").start("+4m");

        roomL.current=new Tone.Loop(()=>{
          if(!rev.current||!widen.current||!pitch.current) return;
          const newDecay=clamp(8+Math.random()*16,4,24);
          const newPre=clamp(0.02+Math.random()*0.12,0.01,0.2);
          const newWidth=clamp(.5+Math.random()*.45,0,1);
          rev.current.set({decay:newDecay,preDelay:newPre});
          rampNorm(widen.current.width,newWidth,1);
          rampNorm(pitch.current.wet,clamp(shimmer*(0.8+Math.random()*0.4),0,1),1);
        }, roomSecs).start(0);

        Tone.Transport.start();
      };

      const stop=()=>{
        Tone.Transport.stop();
        seq.current?.dispose(); padL.current?.dispose(); drL.current?.dispose(); bellL.current?.dispose(); roomL.current?.dispose(); pluckL.current?.dispose(); choirL.current?.dispose();
        lfoWet.current?.dispose();
        pad.current?.dispose(); sp.current?.dispose(); ns.current?.dispose(); nEnv.current?.dispose(); drone.current?.dispose(); sub.current?.dispose(); bell.current?.dispose(); pluck.current?.dispose(); choir.current?.dispose();
        gNoise.current?.dispose(); gEnv.current?.dispose(); gGate.current?.dispose(); gCr.current?.dispose(); gSh.current?.dispose(); gDel.current?.dispose(); gGain.current?.dispose();
        Object.values(layers.current).forEach((L:any)=>{L.filter.dispose();L.chor.dispose();L.phs.dispose();L.lfo1.dispose();L.lfo2.dispose();L.pan.dispose();L.dry.dispose();L.send.dispose();});
        layers.current={};
        rev.current?.dispose(); pitch.current?.dispose(); comp.current?.dispose(); widen.current?.dispose(); master.current?.dispose();
        seq.current=padL.current=drL.current=bellL.current=roomL.current=pluckL.current=choirL.current=null;
        lfoWet.current=null;
        pad.current=sp.current=ns.current=nEnv.current=null;
        drone.current=sub.current=bell.current=pluck.current=choir.current=null;
        gNoise.current=gEnv.current=gGate.current=gCr.current=gSh.current=gDel.current=gGain.current=null;
        rev.current=pitch.current=comp.current=widen.current=master.current=null;
      };

      // live updates
      useEffect(()=>{ if(isOn) Tone.Transport.bpm.rampTo(clamp(tempo,20,200), .5); },[tempo,isOn]);
      useEffect(()=>{ if(isOn&&rev.current) rampNorm(rev.current.wet,clamp(bloom,0,1),.3); },[bloom,isOn]);
      useEffect(()=>{ if(isOn&&pitch.current) rampNorm(pitch.current.wet,clamp(shimmer,0,1),.3); },[shimmer,isOn]);
      useEffect(()=>{ if(isOn&&widen.current) rampNorm(widen.current.width,clamp(spread,0,1),.2); },[spread,isOn]);
      useEffect(()=>{ if(isOn&&master.current) rampNorm(master.current.gain,clamp(masterVol,0,1),.2); },[masterVol,isOn]);
      useEffect(()=>{ if(isOn&&seq.current) seq.current.interval=densityToInterval(density); },[density,isOn]);
      useEffect(()=>{ if(isOn&&layers.current.drone) layers.current.drone.filter.frequency.rampTo(clamp(cutDrone,80,3000),.5); },[cutDrone,isOn]);
      useEffect(()=>{ if(isOn&&drone.current) (drone.current as any).set({detune:clamp(detune,-50,50)}); },[detune,isOn]);
      useEffect(()=>{ if(isOn&&bell.current) (bell.current as any).set({resonance:clamp(4000,500,8000)}); },[isOn]);
      useEffect(()=>{ if(isOn&&gGate.current) gGate.current.frequency.rampTo(grain.mode==='synced'?(grain.rateSync as any):clamp(grain.rateHz,1,24),.1); },[grain.mode,grain.rateSync,grain.rateHz,isOn]);
      useEffect(()=>{ if(isOn&&gCr.current) (gCr.current as any).set({bits:clamp(grain.bits,1,8)}); },[grain.bits,isOn]);
      useEffect(()=>{ if(isOn&&gSh.current) (gSh.current as any).frequency=clamp(grain.shift,.1,12); },[grain.shift,isOn]);
      useEffect(()=>{ if(isOn&&gEnv.current&&gDel.current){ (gEnv.current as any).set(grain.airy?{attack:.02,decay:.25,sustain:0,release:.25}:{attack:.005,decay:.18,sustain:0,release:.12}); (gDel.current as any).set(grain.airy?{delayTime:.1,feedback:.35,wet:.5}:{delayTime:.06,feedback:.2,wet:.25}); } },[grain.airy,isOn]);
      useEffect(()=>{ const s=levels; if(isOn&&pad.current)   (pad.current as any).set({volume:gainToDbSafe01(clamp(s.pad,0,1))}); },[levels.pad,isOn]);
      useEffect(()=>{ const s=levels; if(isOn&&sp.current)    (sp.current as any).set({volume:gainToDbSafe01(clamp(s.sparkle,0,1))}); },[levels.sparkle,isOn]);
      useEffect(()=>{ const s=levels; if(isOn&&ns.current)    (ns.current as any).volume.value=gainToDbSafe01(clamp(s.noise,0,1)); },[levels.noise,isOn]);
      useEffect(()=>{ const s=levels; if(isOn&&drone.current) (drone.current as any).set({volume:gainToDbSafe01(clamp(s.drone,0,1))}); },[levels.drone,isOn]);
      useEffect(()=>{ const s=levels; if(isOn&&sub.current)   (sub.current as any).set({volume:gainToDbSafe01(clamp(s.sub,0,1))}); },[levels.sub,isOn]);
      useEffect(()=>{ const s=levels; if(isOn&&bell.current)  (bell.current as any).set({volume:gainToDbSafe01(clamp(s.bell,0,1))}); },[levels.bell,isOn]);
      useEffect(()=>{ const s=levels; if(isOn&&gGain.current) rampNorm(gGain.current.gain,clamp(s.grain,0,1),.2); },[levels.grain,isOn]);
      useEffect(()=>{ const s=levels; if(isOn&&pluck.current) (pluck.current as any).set({attackNoise: clamp(1 + (s.pluck-0.5), 0.3, 2)}); },[levels.pluck,isOn]);
      useEffect(()=>{ const s=levels; if(isOn&&choir.current) (choir.current as any).set({volume:gainToDbSafe01(clamp(s.choir,0,1))}); },[levels.choir,isOn]);

      // depth/chorus broadcast to all layers
      useEffect(()=>{
        if(!isOn) return;
        const names=Object.keys(layers.current);
        names.forEach(n=>{
          const L=layers.current[n]; if(!L) return;
          L.dry.gain.value=clamp(1-depth,0,1);
          L.send.gain.value=clamp(depth,0,1);
          L.chor.depth=clamp(chorus,0,1);
          L.lfo1.min=-clamp(1-scatter,0,1); L.lfo1.max= clamp(1-scatter,0,1);
          L.lfo2.min=-clamp(scatter,0,1);   L.lfo2.max= clamp(scatter,0,1);
          L.lfo1.frequency.value=Math.max(0.005,orbit);
          L.lfo2.frequency.value=Math.max(0.005,orbit*3.13);
        });
      }, [depth,chorus,scatter,orbit,isOn]);

      // QWERTY + MIDI
      useEffect(()=>{
        const down=new Set<string>();
        const map = (k:string)=> QWERTY_MAP[k];
        const onKey=(ev:KeyboardEvent)=>{
          if(!isOn) return;
          const k=ev.key.toLowerCase();
          if(down.has(k)) return;
          const nn=map(k); if(!nn) return;
          down.add(k);
          const n=nn+"4";
          sp.current?.triggerAttack(n);
          bell.current?.triggerAttack(n);
          pluck.current?.triggerAttack(n);
        };
        const onUp=(ev:KeyboardEvent)=>{
          const k=ev.key.toLowerCase();
          down.delete(k);
          if(QWERTY_MAP[k]){
            sp.current?.triggerRelease();
            bell.current?.triggerRelease();
          }
        };
        window.addEventListener('keydown',onKey); window.addEventListener('keyup',onUp);

        let access:any|undefined;
        (navigator as any).requestMIDIAccess?.().then((a:any)=>{
          access=a;
          a.inputs.forEach((inp:any)=>{
            inp.onmidimessage=(m:any)=>{
              if(!isOn) return;
              const [st,d1,d2]=m.data; const type=st&0xf0;
              if(type===0x90&&d2>0){
                const f=Tone.Frequency(d1, "midi");
                const note=f.toNote();
                const nearest=pool.length? pool.reduce((p,c)=> Math.abs(Tone.Frequency(c).toFrequency()-f.toFrequency())<Math.abs(Tone.Frequency(p).toFrequency()-f.toFrequency())?c:p, pool[0]): note;
                bell.current?.triggerAttack(nearest, undefined, clamp(d2/127, .3, 1));
                pluck.current?.triggerAttack(nearest, undefined, clamp(d2/127, .3, 1));
              }
              if(type===0x80||(type===0x90&&d2===0)){
                bell.current?.triggerRelease();
              }
            };
          });
        });
        return ()=>{
          window.removeEventListener('keydown',onKey);
          window.removeEventListener('keyup',onUp);
        };
      },[isOn, pool.join("")]);


      // tests (simple UI assertions)
      type Test={name:string;pass:boolean}; const [tests,setTests]=useState<Test[]>([]);
      React.useEffect(()=>{
        const eq=(a:any,b:any)=>JSON.stringify(a)==JSON.stringify(b);
        const r:Test[]=[];
        const s=buildScale("C","Lydian",[3]).slice(0,4);
        r.push({name:"C Lydian oct3 starts C3..F#3",pass:eq(s,["C3","D3","E3","F#3"])});
        r.push({name:"density .5 -> 2n",pass:densityToInterval(.5)==="2n"});
        r.push({name:"safe01(1e-7) >= EPS",pass:safe01(1e-7)>=EPS});
        r.push({name:"QWERTY a -> C",pass:QWERTY_MAP['a']==='C'});
        r.push({name:"BPM clamp 220 -> 200", pass: clamp(220,20,200)===200});
        setTests(r);
      },[]);

      return (
        <div className="min-h-screen bg-gradient-to-b from-slate-950 via-slate-900 to-slate-950 text-slate-100 p-6">
          <div className="max-w-6xl mx-auto">
            <header className="flex items-center justify-between mb-4">
              <h1 className="text-2xl md:text-3xl font-semibold">Ethereal Soundscape</h1>
              <div className="flex gap-3">
                {!isOn
                  ? <button onClick={()=>{setOn(true);start();}} className="px-4 py-2 rounded-2xl bg-emerald-500/90 hover:bg-emerald-400 text-slate-900 font-semibold">Start</button>
                  : <button onClick={()=>{setOn(false);stop();}} className="px-4 py-2 rounded-2xl bg-rose-500/90 hover:bg-rose-400 text-slate-900 font-semibold">Stop</button>
                }
              </div>
            </header>
            <p className="text-slate-300 mb-4">Play with your keyboard (A,W,S,E,D… row) or MIDI. Headphones recommended.</p>

            <div className="grid md:grid-cols-3 gap-4">
              <Card title="Scale">
                <div className="grid grid-cols-2 gap-3">
                  <Select label="Root" value={root} onChange={(v)=>setRoot(v as NoteName)} options={NOTE_LIST} />
                  <Select label="Mode" value={scale} onChange={setScale} options={Object.keys(SCALES)} />
                </div>
              </Card>

              <Card title="Flow">
                <Slider label={\`Tempo: \${tempo} BPM\`} min={20} max={200} step={1} value={tempo} onChange={setTempo} />
                <Slider label={\`Sparkle Density: \${density.toFixed(2)} ev/beat\`} min={0.05} max={1} step={0.01} value={density} onChange={setDensity} />
                <Slider label={\`Bell Density: \${bellDensity.toFixed(2)} ev/beat\`} min={0.05} max={0.5} step={0.01} value={bellDensity} onChange={setBellD} />
              </Card>

              <Card title="Space & Motion">
                <Slider label={\`Master Vol: \${(masterVol*100)|0}%\`} min={0} max={1} step={0.01} value={masterVol} onChange={setMaster} />
                <Slider label={\`Bloom (Reverb): \${(bloom*100)|0}%\`} min={0} max={1} step={0.01} value={bloom} onChange={setBloom} />
                <Slider label={\`Shimmer: \${(shimmer*100)|0}%\`} min={0} max={1} step={0.01} value={shimmer} onChange={setShimmer} />
                <Slider label={\`Chorus Depth: \${(chorus*100)|0}%\`} min={0} max={1} step={0.01} value={chorus} onChange={setChorus} />
                <Slider label={\`Stereo Spread: \${(spread*100)|0}%\`} min={0} max={1} step={0.01} value={spread} onChange={setSpread} />
                <Slider label={\`Motion: \${motion.toFixed(2)} Hz\`} min={0.005} max={0.2} step={0.005} value={motion} onChange={setMotion} />
              </Card>

              <Card title="Levels">
                <Slider label={\`Pad \${(levels.pad*100)|0}%\`} min={0} max={1} step={0.01} value={levels.pad} onChange={v=>setLevels({...levels,pad:v})} />
                <Slider label={\`Sparkle \${(levels.sparkle*100)|0}%\`} min={0} max={1} step={0.01} value={levels.sparkle} onChange={v=>setLevels({...levels,sparkle:v})} />
                <Slider label={\`Noise \${(levels.noise*100)|0}%\`} min={0} max={1} step={0.01} value={levels.noise} onChange={v=>setLevels({...levels,noise:v})} />
                <Slider label={\`Drone \${(levels.drone*100)|0}%\`} min={0} max={1} step={0.01} value={levels.drone} onChange={v=>setLevels({...levels,drone:v})} />
                <Slider label={\`Sub \${(levels.sub*100)|0}%\`} min={0} max={1} step={0.01} value={levels.sub} onChange={v=>setLevels({...levels,sub:v})} />
                <Slider label={\`Bells \${(levels.bell*100)|0}%\`} min={0} max={1} step={0.01} value={levels.bell} onChange={v=>setLevels({...levels,bell:v})} />
                <Slider label={\`Grain \${(levels.grain*100)|0}%\`} min={0} max={1} step={0.01} value={levels.grain} onChange={v=>setLevels({...levels,grain:v})} />
                <Slider label={\`Pluck \${(levels.pluck*100)|0}%\`} min={0} max={1} step={0.01} value={levels.pluck} onChange={v=>setLevels({...levels,pluck:v})} />
                <Slider label={\`Choir \${(levels.choir*100)|0}%\`} min={0} max={1} step={0.01} value={levels.choir} onChange={v=>setLevels({...levels,choir:v})} />
              </Card>

              <Card title="Drones">
                <Slider label={\`Cutoff: \${cutDrone|0} Hz\`} min={80} max={3000} step={5} value={cutDrone} onChange={setCutDrone} />
                <Slider label={\`Detune: \${detune|0} cents\`} min={-30} max={30} step={1} value={detune} onChange={setDetune} />
              </Card>

              <Card title="Granular">
                <Toggle label={\`Mode: \${grain.airy?'Shimmer':'Sand'}\`} checked={grain.airy} onChange={(v)=>setGrain({...grain,airy:v})} />
                <Select label="Rate Type" value={grain.mode} onChange={(v)=>setGrain({...grain,mode:v as any})} options={["synced","hz"]} />
                {grain.mode==='synced'
                  ? <Select label="Synced" value={grain.rateSync} onChange={(v)=>setGrain({...grain,rateSync:v})} options={["16n","8n","4n","4n.","2n","1n","1n.","2m"]} />
                  : <Select label="Rate Hz" value={String(grain.rateHz)} onChange={(v)=>setGrain({...grain,rateHz:parseFloat(v)})} options={["2","4","6","8","9","12","16","20","24"]} />
                }
                <Slider label={\`Bits: \${grain.bits|0}\`} min={1} max={8} step={1} value={grain.bits} onChange={(v)=>setGrain({...grain,bits:v})} />
                <Slider label={\`Shift: \${grain.shift.toFixed(1)} Hz\`} min={0.1} max={12} step={0.1} value={grain.shift} onChange={(v)=>setGrain({...grain,shift:v})} />
              </Card>

              <Card title="Spatial + Room">
                <Slider label={\`Orbit: \${orbit.toFixed(3)} Hz\`} min={0.005} max={0.05} step={0.001} value={orbit} onChange={setOrbit} />
                <Slider label={\`Depth: \${(depth*100)|0}%\`} min={0} max={1} step={0.01} value={depth} onChange={setDepth} />
                <Slider label={\`Scatter: \${(scatter*100)|0}%\`} min={0} max={1} step={0.01} value={scatter} onChange={setScatter} />
                <Slider label={\`Room morph (s): \${roomSecs}\`} min={20} max={600} step={5} value={roomSecs} onChange={setRoomSecs} />
              </Card>

              <Card title="Self‑tests">
                <ul className="space-y-1 text-xs">
                  <li className="text-slate-400">Console shows full output.</li>
                  {tests.map((t,i)=>(
                    <li key={i} className={t.pass?"text-emerald-300":"text-rose-300"}>
                      {t.pass?"✔":"✘"} {t.name}
                    </li>
                  ))}
                </ul>
              </Card>
            </div>

            <footer className="mt-6 text-xs text-slate-500">
              Tone.js • Audio starts after a user gesture. Browser tab must be unmuted.
              <br/>MIDI input requires HTTPS (GitHub Pages is fine).
            </footer>
          </div>
        </div>
      );
    }

    function Card({title,children}:{title:string;children:React.ReactNode}){
      return (<div className="bg-white/5 border border-white/10 rounded-2xl p-4">
        <div className="text-sm text-slate-300 mb-2">{title}</div>{children}
      </div>);
    }
    function Slider({label,min,max,step,value,onChange}:{label:string;min:number;max:number;step:number;value:number|string;onChange:(v:any)=>void}){
      return (<label className="block text-sm">
        <div className="mb-1 text-slate-300">{label}</div>
        <input type="range" min={min} max={max} step={step} value={value as number} onChange={(e)=>onChange(parseFloat((e.target as HTMLInputElement).value))} className="w-full accent-emerald-400"/>
      </label>);
    }
    function Select({label,value,onChange,options}:{label:string;value:string;onChange:(v:string)=>void;options:string[]}){
      return (<label className="block text-sm">
        <div className="mb-1 text-slate-300">{label}</div>
        <select value={value} onChange={(e)=>onChange((e.target as HTMLSelectElement).value)} className="w-full bg-white/5 border border-white/10 rounded-xl px-3 py-2">
          {options.map(o=>(<option key={o} value={o}>{o}</option>))}
        </select>
      </label>);
    }
    function Toggle({label,checked,onChange}:{label:string;checked:boolean;onChange:(v:boolean)=>void}){
      return (<label className="flex items-center justify-between text-sm select-none">
        <span className="text-slate-300 mr-3">{label}</span>
        <button type="button" onClick={()=>onChange(!checked)} className={\`w-12 h-6 rounded-full transition \${checked?'bg-emerald-500/80':'bg-white/15'} relative\`}>
          <span className={\`absolute top-0.5 \${checked?'left-6':'left-0.5'} w-5 h-5 rounded-full bg-white/90\`} />
        </button>
      </label>);
    }

    const root = ReactDOM.createRoot(document.getElementById("root")!);
    root.render(<App />);
  </script>
</body>
</html>
